// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

contract PairingTest {

    // -A
    uint256 constant aG1_x =
        2810973869280143996944754043944300099901689961369777122088380157702686388141;
    uint256 constant aG1_y =
        9912032970174929234396460622494044845731727296703753669287128168658791287629;

    // B
    uint256 constant bG2_x1 =
        15037922396844586663633914037780016796794140784553104225171629432393758154966;
    uint256 constant bG2_x2 =
        20261299963341350882217315937947605261651953838920578715049632121387608371289;
    uint256 constant bG2_y1 =
        1692897509143376720355417257643923016301630509692460586318287210703035742316;
    uint256 constant bG2_y2 =
        3150698043188242623271902648897205312336583829074322481424629828127492829586;

    // alpha
    uint256 constant alphaG1_x =
        10802612347318313037890906740882992824871433947249475863368584924217162773340;
    uint256 constant alphaG1_y =
        21665519960768647337306136389906518106565486495562835916276783239219087421964;

    // beta
    uint256 constant betaG2_x1 =
        15841140191628158406231625516278735597230244711106612046831996165864283914795;
    uint256 constant betaG2_x2 =
        7440922372613423623605686747868109307480657008093127191481042628988149982433;
    uint256 constant betaG2_y1 =
        2516628800848056896031187065663056590539810098669516243837429031693648191504;
    uint256 constant betaG2_y2 =
        18855261300236861398295813954464818636581856967694518078298944928904957856549;

    uint256 constant cG1_x =
        18558111906212008875470509189141457061249867140578645331532857237503574141462;
    uint256 constant cG1_y =
        1458712157753854243416006666287707368709177968162491220902261906674502344540;

    uint256 constant Q =
        21888242871839275222246405745257275088696311157297823662689037894645226208583;

    function run(bytes memory input) public view returns (bool) {
        // optional, the precompile checks this too and reverts (with no error) if false, this helps narrow down possible errors
        if (input.length % 192 != 0) revert("Points must be a multiple of 6");
        (bool success, bytes memory data) = address(0x08).staticcall(input);
        if (success) return abi.decode(data, (bool));
        revert("Wrong pairing");
    }

    function verify() public view returns (bool) {
        // -A * B + alpha * betta + C = 0
        bytes memory points1 = abi.encode(
            aG1_x,
            aG1_y,
            bG2_x2,
            bG2_x1,
            bG2_y2,
            bG2_y1,
            alphaG1_x,
            alphaG1_y,
            betaG2_x2,
            betaG2_x1,
            betaG2_y2,
            betaG2_y1
        );

        bytes memory points2 = abi.encode(
            cG1_x,
            cG1_y,
            11559732032986387107991004021392285783925812861821192530917403151452391805634,
            10857046999023057135944570762232829481370756359578518086990519993285655852781,
            4082367875863433681332203403145435568316851327593401208105741076214120093531,
            8495653923123431417604973247489272438418190587263600148770280649306958101930
        );

        bytes memory points = abi.encodePacked(points1, points2);

        bool x = run(points);
        return x;
    }
}